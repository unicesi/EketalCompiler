/*
 * generated by Xtext 2.9.2
 */
package co.edu.icesi.eketal.jvmmodel

import co.edu.icesi.eketal.eketal.Model
import com.google.inject.Inject
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import java.util.TreeMap
import java.util.Set
import org.eclipse.xtext.common.types.JvmVisibility
import co.edu.icesi.eketal.eketal.Group
import java.util.HashSet
import co.edu.icesi.eketal.eketal.StateType
import co.edu.icesi.ketal.core.State
import co.edu.icesi.ketal.core.Event
import java.util.Map
import java.util.HashMap
import co.edu.icesi.ketal.core.Automaton
import co.edu.icesi.ketal.core.Transition
import co.edu.icesi.ketal.core.DefaultEqualsExpression
import java.util.TreeSet
import org.eclipse.xtext.naming.IQualifiedNameProvider
import co.edu.icesi.eketal.outputconfiguration.OutputConfigurationAdapter
import co.edu.icesi.ketal.core.NamedEvent
import org.eclipse.xtext.generator.IFileSystemAccess
import co.edu.icesi.eketal.eketal.EventClass
import co.edu.icesi.ketal.distribution.BrokerMessageHandler
import co.edu.icesi.ketal.distribution.ReceiverMessageHandler
import co.edu.icesi.ketal.distribution.EventBroker
import co.edu.icesi.ketal.distribution.transports.jgroups.JGroupsEventBroker
import java.util.Hashtable
import co.edu.icesi.ketal.core.Expression
import org.jgroups.Message
import co.edu.icesi.eketal.eketal.Rc
import co.edu.icesi.eketal.eketal.Pos
import java.net.URL
import co.edu.icesi.eketal.eketal.JVarD
import java.net.MalformedURLException
import co.edu.icesi.eketal.eketal.Host
import java.util.regex.Pattern
import java.util.Collections
import co.edu.icesi.eketal.eketal.MSig
import co.edu.icesi.eketal.eketal.Ltl
import co.edu.icesi.eketal.eketal.LtlExpression
import co.edu.icesi.ltl2buchi.translator.BuchiTranslator
import co.edu.icesi.eketal.eketal.LtlOr
import co.edu.icesi.eketal.eketal.LtlAnd
import co.edu.icesi.eketal.eketal.UnaryLtl
import co.edu.icesi.eketal.eketal.LtlUntil
import co.edu.icesi.eketal.eketal.LtlThen
import co.edu.icesi.ketal.core.BuchiAutomaton
import co.edu.icesi.ketal.core.BuchiTransition
import java.io.BufferedReader
import java.io.StringReader
import java.util.ArrayList
import java.util.List
import co.edu.icesi.ketal.core.NotExpression
import co.edu.icesi.ketal.core.Or
import java.util.Arrays
import co.edu.icesi.ketal.core.And
import org.eclipse.xtend2.lib.StringConcatenationClient
import co.edu.icesi.ketal.core.TrueExpression
import co.edu.icesi.eketal.eketal.Protocol

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class EketalJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	@Inject extension IQualifiedNameProvider

	public static String PREFIX_NAME_FOR_GROUP_CLASSES = "_GroupsControl"
	public static String PREFIX_NAME_FOR_EVENT_CLASSES = "_EventHandler"
	public static String PREFIX_NAME_FOR_REACTION_CLASSES = "_Reaction"

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link org.eclipse.xtext.common.types.JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link org.eclipse.xtext.common.types.JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the closure you pass to the returned
	 *            {@link org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor.IPostIndexingInitializing#initializeLater(org.eclipse.xtext.xbase.lib.Procedures.Procedure1)
	 *            initializeLater(..)}.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(Model element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
//		println("Inferring model for " + element.name)
		val implementation = element.toClass(element.fullyQualifiedName)

		if (implementation === null)
			return;

		var eventClassDefinition = element.typeDeclaration
		
		var eventClassToGenerate = eventClassDefinition.toClass(eventClassDefinition.fullyQualifiedName)

//		eventClassGenerate.eAdapters.add(new OutputConfigurationAdapter(EketalOutputConfigurationProvider::ASPECTJ_OUTPUT))
		eventClassToGenerate.eAdapters.add(new OutputConfigurationAdapter(IFileSystemAccess.DEFAULT_OUTPUT))

		acceptor.accept(eventClassToGenerate) [
			println("línea 97 Inferrer")
		]

		/*
		 * Creates a class that contains the groups declared
		 */
		val groupDefinitions = element.typeDeclaration
		createGroupClass(acceptor, groupDefinitions)

		var buchiAutomatonDefinitions = element.typeDeclaration.declarations.filter(typeof(Ltl));
		createBuchis(acceptor, buchiAutomatonDefinitions)

		// val eventsOfLtlFormula = buchis.toInvertedMap [ a |
		// val Set<String> steps = new TreeSet
		// steps.addAll(a.steps.toSet)//.forEach[s|s.transitions.forall[t|events.add(t.event.name)]]
		// a.predicate.event
		// return steps
		// ]
		/*
		 * Collects all the automatons
		 */
		var automatonDefinitions = element.typeDeclaration.declarations.filter(typeof(co.edu.icesi.eketal.eketal.Automaton));
		
		/*
		 * Returns a where the keys are automatons and the values are the states of that automaton.
		 */
		val eventsRepresentedByMapAutomatonToStates = automatonDefinitions.toInvertedMap [ automaton |
			val Set<String> setOfStatesByAutomaton = new TreeSet
			automaton.steps.forall[state|setOfStatesByAutomaton.add(automaton.name + ":" + state.name)]
			return setOfStatesByAutomaton
		]
	
		/*
		 *  Creates an automaton java class for each one automaton in 'automatons'
		 */
		var String nameAutomaton;
		for (declaracion : automatonDefinitions) {
			// Debe ir con la ruta para el que compilador entienda que no es el objeto automáta de la libreria ketal, sino el elmento automata de la definicion del lenguaje (es decir, la producción)
			/*
			 * Creates the class with the singleton nature
			 */
			nameAutomaton = "co.edu.icesi.eketal.automaton." + declaracion.name.toFirstUpper

			acceptor.accept(declaracion.toClass(nameAutomaton)) [
				// superTypes+=entity.superType.cloneWithProxies
				val typeAutomaton = typeRef(it)
				superTypes += typeRef(Automaton)
				members += declaracion.toField("instance", typeAutomaton)[static = true]
				members += declaracion.toField("estados", typeRef(HashMap, typeRef(String), typeRef(State))) [
					static = true
					visibility = JvmVisibility::PUBLIC
					initializer = '''new «typeRef(HashMap)»<String, «typeRef(State)»>()'''
				]

				members += declaracion.toMethod("getInstance", typeRef(Automaton)) [
					static = true
					body = '''
						if(instance==null){
							//lista de estados finales
							«typeRef(Set, typeRef(State))» estadosFinales = new «typeRef(HashSet)»();
							//conjunto de transiciones
							  	«typeRef(Set, typeRef(Transition))» transitionSet = new «typeRef(HashSet)»();
							//map de expresiones con caracteres
							  	«typeRef(Hashtable, typeRef(Expression), typeRef(Character))» expressions = new «typeRef(Hashtable)»();
							  	«typeRef(State)» initial = initialize(transitionSet, estadosFinales, expressions);
							return new «typeAutomaton»(transitionSet, initial, estadosFinales, expressions);
						}else{
							return instance;						
						}
					'''
				]

				members += declaracion.toMethod("evaluate", typeRef(boolean)) [
//					annotations+=annotationRef(typeRef(Override).class)
					parameters += declaracion.toParameter("event", typeRef(Event))
					body = '''
						if(event instanceof «typeRef(NamedEvent)»){
						   			return super.evaluate(event);
						   		}
						   		return false;
					'''
				]

				members += declaracion.toConstructor [
					visibility = JvmVisibility::PRIVATE
					parameters += declaracion.toParameter("transitions", typeRef(Set, typeRef(Transition)))
					parameters += declaracion.toParameter("begin", typeRef(State))
					parameters += declaracion.toParameter("finalStates", typeRef(Set, typeRef(State)))
					parameters +=
						declaracion.toParameter("expressions",
							typeRef(Hashtable, typeRef(Expression), typeRef(Character)))
					body = '''
						super(transitions, begin, finalStates, expressions);
						initializeAutomaton();
						instance = this;
					'''
				]
				/*
				 * Creates the main method
				 */
				members += initializeAutomaton(declaracion as co.edu.icesi.eketal.eketal.Automaton)
			]

		}
		
		
		
		/*
		 * Creates the class that contains the required reactions
		 */
		var reactions = element.typeDeclaration;
		createReactionClass(acceptor, reactions, eventsRepresentedByMapAutomatonToStates)

		/*
		 * Creates the class that handles the control in the jgroups
		 */
		val handlerClass = element.typeDeclaration;
		createHandlerClass(acceptor, handlerClass, automatonDefinitions.toSet, buchiAutomatonDefinitions.toSet)

	}

	def createBuchis(IJvmDeclaredTypeAcceptor acceptor, Iterable<Ltl> ltls) {
		var String nameAutomaton;
		for (Ltl ltl : ltls) {
			if (ltl.predicate !== null) {
				// Obtiene predicado de la formula
				var LtlExpression tPredicate = ltl.predicate
				// Recupera la formula completa
				if(tPredicate===null){
					return
				}
				var String formulae = retrieveFormula(tPredicate)
				println(formulae)
				val String buchiMachine = BuchiTranslator.translateToString(formulae)
				println(buchiMachine)
				nameAutomaton = "co.edu.icesi.eketal.buchiautomaton." + ltl.name.toFirstUpper

				acceptor.accept(ltl.toClass(nameAutomaton)) [
					// superTypes+=entity.superType.cloneWithProxies
					val typeAutomaton = typeRef(it)
					superTypes += typeRef(BuchiAutomaton)
					members += ltl.toField("instance", typeAutomaton)[static = true]
					members += ltl.toField("estados", typeRef(HashMap, typeRef(String), typeRef(State))) [
						static = true
						visibility = JvmVisibility::PUBLIC
						initializer = '''new «typeRef(HashMap)»<String, «typeRef(State)»>()'''
					]
					
					members += ltl.toMethod("getInstance", typeRef(BuchiAutomaton)) [
						static = true
						documentation = buchiMachine
						body = '''
							if(instance==null){
								//lista de estados finales
								«typeRef(Set, typeRef(State))» estadosFinales = new «typeRef(HashSet)»();
								//conjunto de transiciones
								  	«typeRef(Set, typeRef(BuchiTransition))» transitionSet = new «typeRef(HashSet)»();
								//map de expresiones con caracteres
								  	«typeRef(Hashtable, typeRef(Expression), typeRef(Character))» expressions = new «typeRef(Hashtable)»();
								  	«typeRef(State)» initial = initialize(transitionSet, estadosFinales, expressions);
								return new «typeAutomaton»(transitionSet, initial, estadosFinales, expressions);
							}else{
								return instance;						
							}
						'''
					]

					members += ltl.toConstructor [
						visibility = JvmVisibility::PRIVATE
						parameters += ltl.toParameter("transitions", typeRef(Set, typeRef(BuchiTransition)))
						parameters += ltl.toParameter("begin", typeRef(State))
						parameters += ltl.toParameter("finalStates", typeRef(Set, typeRef(State)))
						parameters +=
							ltl.toParameter("expressions", typeRef(Hashtable, typeRef(Expression), typeRef(Character)))
						body = '''
							super(transitions, begin, finalStates, expressions);
							findTransitionsCurrentState();
							instance = this;
						'''
					]
					/*
					 * Creates the main method
					 */
					members += initializebuchiAutomaton(buchiMachine, ltl as Ltl)
				]
			}
		}
	}

	def initializebuchiAutomaton(String buchiFormulae, Ltl declaracion) {
		
		var BufferedReader bufReader = new BufferedReader(new StringReader(buchiFormulae));
		val TreeMap<String, List<String>> states = new TreeMap
		val List<String> finalStates = new ArrayList;
		var String line=null;
		var String init
		/*
		 * The method replaceAll will erase the characters followed by this regular expression, in other words
		 * the ones contained in the brackets: comma, parentheses and dots.
		 */
		var regex = "[().,]+"
		while( (line=bufReader.readLine()) !== null ){
			if(line.startsWith("S")){
				var tempState = line.split("=")
				init = tempState.get(0)
				//S0=(!green-> S0 |!red-> S1 |yellow-> S0),
				//S1=(!red-> S1 |yellow-> S0).
				var transitions = tempState.get(1)
				val transitionOfState = newArrayList
				if(transitions!==null && transitions!=""){
					//(!red-> S1 |yellow-> S0).
					var result = transitions.replaceAll(regex,"")
					//!green-> S0 |!red-> S1 |yellow-> S0
					//Agrupa por el estado de llegada
					//{S0,!green-> S0, yellow-> S0},{S1,!red-> S1}
					//Con el foreach se toma cada llave (estado de llegada) y se relaciona en un Map con las transiciones que llegan a dicho estado.
					//Finalmente, se concatenan por medio del || 
					//val trans = newHashMap
					//result.split(Pattern.quote("|")).groupBy[t|t.split(Pattern.quote("->")).get(1).trim].forEach[stt,values|trans.put(stt,values.join(Pattern.quote("||")))]
					result.split(Pattern.quote("|")).groupBy[
						t|t.split(Pattern.quote("->")).get(1).trim
					].forEach[
						//adds each trigger value grouped by the target state
						stt,values|
						transitionOfState.add(values.join("|")[x|x.split(Pattern.quote("->")).get(0)]+"->"+stt)
					]
					states.put(init, transitionOfState)
				}else{					
					states.put(init, null)
				}
			}else if(line.startsWith("RES")){
				//Segunda línea estado inicial
				//RES = S0,
				states.put(line.substring(6, line.length-1), null)
			}else if(line.startsWith("AS")){
				//Última línea estados finales
				//AS = { S1, S2 }
				line.substring(0,line.length-1).split(Pattern.quote("{")).get(1).split(",").forEach[s|
					finalStates.add(s.trim)
				]
				//finalStates.addAll(line.substring(0,line.length-1).split("{").get(1).split(",").forEach[s|s.trim])
			}else if(line.equals("Empty")){
				return null
			}else{
				//Primera línea la definición
				
			}
		}
		val setStates = states.keySet
		val String initial = setStates.head
		
		val method = declaracion.toMethod("initialize", typeRef(State)) [
			parameters += declaracion.toParameter("transitionSet", typeRef(Set, typeRef(BuchiTransition)))
			parameters += declaracion.toParameter("estadosFinales", typeRef(Set, typeRef(State)))
			parameters += declaracion.toParameter("expressions",
				typeRef(Hashtable, typeRef(Expression), typeRef(Character)))
			static = true
			visibility = JvmVisibility::PRIVATE
			
			body = '''
				//Relación evento caracter
				«typeRef(Map, typeRef(Expression), typeRef(Character))» mapping = new «typeRef(TreeMap, typeRef(Expression), typeRef(Character))»();
				//Estado inicial
				«typeRef(State)» inicial = null;
				
				int consecutivo = 65;
				«Character» caracter = (char)consecutivo;
				«Expression» expression;
				«String» estadoLlegada = "";
				
				«FOR step : setStates»
					//Definición del estado: «step»
					String estado«step.toFirstUpper» = "«step»";
					estados.put(estado«step.toFirstUpper», new «typeRef(State)»());
					«IF step==initial»
						//Estado inicial: «step»
						inicial = estados.get(estado«step.toFirstUpper»);
					«ENDIF»
				«ENDFOR»
				
				«FOR step : setStates»	
					«IF states.get(step)!==null»
						«FOR transition : states.get(step)»
							«var splitTransition = transition.split("->")»
							//Transicion «transition»
							estadoLlegada = "«splitTransition.get(1)»";
							if(!estados.containsKey(estadoLlegada)){
								estados.put(estado«step.toFirstUpper», new «typeRef(State)»());
							}
							caracter = (char)consecutivo;
							consecutivo++;
							expression = «processExpression(splitTransition.get(0))»;
							if(!expressions.containsKey(expression)){
								expressions.put(expression, caracter);
							}
							«typeRef(BuchiTransition)» «step»«splitTransition.get(1).toFirstUpper» = new «typeRef(BuchiTransition)»(estados.get(estado«step.toFirstUpper»), estados.get(estadoLlegada), expressions.get(expression), expression);
							transitionSet.add(«step»«splitTransition.get(1).toFirstUpper»);
							
						«ENDFOR»
					«ENDIF»
					
					«IF finalStates.contains(step)»
						//Estado final «step.toFirstUpper»
						estados.get(estado«step.toFirstUpper»).setAccept(true);
						estadosFinales.add(estados.get(estado«step.toFirstUpper»));
					«ENDIF»
				«ENDFOR»
				return inicial;
			'''
		]
		return method
	}
	
	def private StringConcatenationClient processExpression(String expression) {
		if(expression.contains("|")){
			var array = expression.split(Pattern.quote("|"))
			val left = array.get(0)
			val right = Arrays.copyOfRange(array, 1, array.length).join("|")
			return '''new «Or»(«processExpression(left)»,«processExpression( right)»)'''
		}else if(expression.contains("&")){
			var array = expression.split(Pattern.quote("&"))
			val left = array.get(0)
			val right = Arrays.copyOfRange(array, 1, array.length).join("&")
			return '''new «And»(«processExpression(left)»,«processExpression( right)»)'''
		}else if(expression.startsWith("!")){
			return '''new «NotExpression»(«processExpression( expression.substring(1))»)'''
		}else{
			if(expression.equalsIgnoreCase("TRUE"))
				return '''new «TrueExpression»()'''
			else
				return '''new «DefaultEqualsExpression»(new «NamedEvent»("«expression»"))'''
		}
	}

	def private String retrieveFormula(LtlExpression expression) {
		if (expression.event !== null) {
			return expression.event.name
		}
		switch (expression) {
			LtlOr: {
				var or = expression as LtlOr
				return "(" + retrieveFormula(or.left) + "||" + retrieveFormula(or.right) + ")"
			}
			LtlAnd: {
				var and = expression as LtlAnd
				return "(" + retrieveFormula(and.left) + "&&" + retrieveFormula(and.right) + ")"
			}
			LtlUntil: {
				var until = expression as LtlUntil
				return "(" + retrieveFormula(until.left) + ")U(" + retrieveFormula(until.right) + ")"
			}
			LtlThen: {
				var then = expression as LtlThen
				return "(" + retrieveFormula(then.left) + ")->(" + retrieveFormula(then.right) + ")"
			}
			UnaryLtl: {
				var unary = expression as UnaryLtl
				switch (unary.op) {
					case "!": {
						return "!(" + retrieveFormula(unary.expr) + ")"
					}
					case "next": {
						return "X(" + retrieveFormula(unary.expr) + ")"
					}
					case "always": {
						return "[](" + retrieveFormula(unary.expr) + ")"
					}
					case "eventually": {
						return "<>(" + retrieveFormula(unary.expr) + ")"
					}
				}
			}
		}
	}

	def createReactionClass(IJvmDeclaredTypeAcceptor acceptor, EventClass reactions, Map automatonsMap) {
		acceptor.accept(reactions.toClass("co.edu.icesi.eketal.reaction." + PREFIX_NAME_FOR_REACTION_CLASSES)) [
			val set = reactions.declarations.filter(typeof(Rc))
			val variables = reactions.declarations.filter(typeof(JVarD))
			if (!variables.isEmpty) {
				for (variable : variables) {
					members += reactions.toField(variable.name.toFirstLower, variable.type) [
						static = true
					]
				}
			}
			
			members+=reactions.toMethod("onViolation", typeRef(void))[
				static = true
				body = '''
					System.out.println("Formulae violated");
					//System.exit(0);
				'''
			]
			
			val operations = reactions.declarations.filter(typeof(MSig))
			if (!operations.isEmpty) {
				for (method : operations) {
					members += reactions.toMethod(method.name.toFirstLower, method.type ?: inferredType) [
						static = true
						for (p : method.params) {
							parameters += p.toParameter(p.name, p.parameterType)
						}
						body = method.body
					]
				}
			}

			val after = new HashMap<String, String>()
			val before = new HashMap<String, String>()
			for (rc : set) {
				if (rc.automaton === null || rc.state === null)
					return
				var name = "reaction" + rc.automaton.name + rc.state.name
				members += reactions.toMethod(name, typeRef(void)) [
					static = true
					body = rc.body.body
				]
				if (rc.pos == Pos.BEFORE) {
					before.put(rc.automaton.name + ":" + rc.state.name, name + "()")
				} else if (rc.pos == Pos.AFTER) {
					after.put(rc.automaton.name + ":" + rc.state.name, name + "()")
				}
			}
			members += reactions.toMethod("verifyBefore", typeRef(void)) [
				parameters += reactions.toParameter("automaton", typeRef(Automaton))
				static = true
				synchronized = true
				body = '''
					«IF !before.isEmpty»
						«typeRef(State)» actual = automaton.getCurrentState();
						«FOR state:before.keySet»	
							«FOR automaton:automatonsMap.keySet.map[a|a as co.edu.icesi.eketal.eketal.Automaton]»
								«IF (automatonsMap.get(automaton) as Set<String>).contains(state)»
									if(co.edu.icesi.eketal.automaton.«automaton.name.toFirstUpper».class.isInstance(automaton)){
										if(actual.equals(co.edu.icesi.eketal.automaton.«automaton.name.toFirstUpper».estados.get("«state.split(Pattern.quote(":")).get(1)»"))){
											«before.get(state)»;
										}
									}
								«ENDIF»
							«ENDFOR»								
						«ENDFOR»
						
					«ENDIF»
				'''
			]

			members += reactions.toMethod("verifyAfter", typeRef(void)) [
				static = true
				parameters += reactions.toParameter("automaton", typeRef(Automaton))
				body = '''
					«IF !after.isEmpty»
						«typeRef(State)» actual = automaton.getCurrentState();
						«FOR state:after.keySet»
							«FOR automaton:automatonsMap.keySet.map[a|a as co.edu.icesi.eketal.eketal.Automaton]»
								«IF automaton.steps.contains(state)»
									if(automaton.getClass().isAssignableFrom(co.edu.icesi.eketal.automaton.«automaton.name.toFirstUpper».class){
										if(actual.equals(co.edu.icesi.eketal.automaton.«automaton.name.toFirstUpper».estados.get("«state.split(Pattern.quote(":")).get(1)»"))){
											«after.get(state)»;
										}
									}
								«ENDIF»
							«ENDFOR»
						«ENDFOR»
					«ENDIF»
				'''
			]

		]
	}
	
	
	/*
	 * Also adds the Singleton nature
	 */
	def createHandlerClass(IJvmDeclaredTypeAcceptor acceptor, EventClass eventDefinitionClass, Set<co.edu.icesi.eketal.eketal.Automaton> machines, Set<Ltl> buchis) {
		val protocol = eventDefinitionClass.protocol
		println("protocol"+protocol)
		val matchInterface = eventDefinitionClass.interface
		println("interfaces"+matchInterface)
		
		val automatons = machines.map[a|a as co.edu.icesi.eketal.eketal.Automaton].toSet
		acceptor.accept(eventDefinitionClass.toClass("co.edu.icesi.eketal.handlercontrol." + PREFIX_NAME_FOR_EVENT_CLASSES)) [
			// Implementación de la simulación Singleton
			members += eventDefinitionClass.toField("instance", typeRef(it)) [
				static = true
				initializer = '''new «PREFIX_NAME_FOR_EVENT_CLASSES»()'''
			]

			members += eventDefinitionClass.toField("brokerMessageHandler", typeRef(BrokerMessageHandler)) [
				static = true
			]
			members += eventDefinitionClass.toField("eventBroker", typeRef(EventBroker)) [
				static = true
			]

			members += eventDefinitionClass.toConstructor [
				visibility = JvmVisibility.PRIVATE
				body = '''
					brokerMessageHandler = new «typeRef(ReceiverMessageHandler)»(){
						@Override
						public Object handle(«typeof(Event)» event, «typeof(Map)» metadata, «typeof(Message)» msg,
						    			«typeof(int)» typeOfMsgSent){
						    if(event.getLocalization().equals(eventBroker.getAsyncAddress())){
						    	return null;
						    }
							Object handle = super.handle(event, metadata, msg, typeOfMsgSent);
							«FOR nameAutomaton : automatons»
								«typeRef(Automaton)» automaton«nameAutomaton.name.toFirstUpper» = co.edu.icesi.eketal.automaton.«nameAutomaton.name.toFirstUpper».getInstance();
								if(!automaton«nameAutomaton.name.toFirstUpper».evaluate(event)){
									«typeRef(ReceiverMessageHandler)».getLogger().info("[Handle] Event not recognized by the automaton: «nameAutomaton.name.toFirstUpper»");
												//System.out.println("[Handle] Event not recognized by the automaton: «nameAutomaton.name.toFirstUpper»");
											}else{
												«typeRef(ReceiverMessageHandler)».getLogger().info("[Handle] Recognized event "+event+" in «nameAutomaton.name»");
												//System.out.println("[Handle] Recognized event "+event+" by automaton «nameAutomaton.name»");							
												co.edu.icesi.eketal.reaction.«PREFIX_NAME_FOR_REACTION_CLASSES».verifyBefore(automaton«nameAutomaton.name.toFirstUpper»);					
												co.edu.icesi.eketal.reaction.«PREFIX_NAME_FOR_REACTION_CLASSES».verifyAfter(automaton«nameAutomaton.name.toFirstUpper»);					
											}
							«ENDFOR»
							
							«FOR buchi: buchis»
								«typeRef(Automaton)» automaton«buchi.name.toFirstUpper» = co.edu.icesi.eketal.buchiautomaton.«buchi.name.toFirstUpper».getInstance();
								if(!automaton«buchi.name.toFirstUpper».evaluate(event)){
									co.edu.icesi.eketal.reaction.«PREFIX_NAME_FOR_REACTION_CLASSES».onViolation();
								}else{
									«typeRef(ReceiverMessageHandler)».getLogger().info("[Handle] Event respects the property «buchi.name»");
								}
							«ENDFOR»
									
							return handle;
						}
					};
					«IF (protocol===null || protocol==Protocol.UDP) && matchInterface===null»
						eventBroker = new «typeRef(JGroupsEventBroker)»("Eketal", brokerMessageHandler, true);
					«ELSE»
						eventBroker = new «typeRef(JGroupsEventBroker)»("Eketal", brokerMessageHandler, true, props);
					«ENDIF»
				'''
			// TODO automaton name
			// TODO if
			]
			
			if((protocol!==null && protocol!=Protocol.UDP) || matchInterface!==null){
				//creates the default protocol field
				members+=eventDefinitionClass.toField("props", typeRef(String))[
					if(protocol===null || protocol==Protocol.UDP){
						initializer = generateUDP(matchInterface)
					}else{
						//Collects the hosts
						val ips = new TreeSet()
						eventDefinitionClass.declarations.filter(typeof(Group)).forEach [
							it.hosts.forEach[g|
								if(g.ip!="localhost"){
									ips+=g.ip
								}
							]
						]
						initializer = generateTcpProperties(matchInterface, protocol, ips)
					}
				]
			}
			
			members += eventDefinitionClass.toMethod("getInstance", typeRef(it)) [
				static = true
				body = '''
					if(instance==null)
						instance = new «PREFIX_NAME_FOR_EVENT_CLASSES»();
					return instance;
				'''
			]
			// Aquí termina la definición sintética del Sigleton
			// TODO en este es el mulsticasSync o el Async?
			members += eventDefinitionClass.toMethod("multicast", typeRef(void)) [
				parameters += eventDefinitionClass.toParameter("evento", Event.typeRef)
				parameters += eventDefinitionClass.toParameter("map", Map.typeRef)
				static = false
				body = '''
					eventBroker.multicast(evento, map);
				'''
			]

			members += eventDefinitionClass.toMethod("getAsyncAddress", typeRef(URL)) [
				static = false
				body = '''
					«typeof(URL)» url = eventBroker.getAsyncAddress();
					if(url!=null){
						return url;
					}else{
						«typeRef(ReceiverMessageHandler)».getLogger().error("[Handle] Could not obtain JGroups ip Address for the async monitor");
						try{
							return new «URL»("http:127.0.0.1");
						}catch(«typeRef(MalformedURLException)» e){
							«typeRef(ReceiverMessageHandler)».getLogger().error("[Handle] "+e.getMessage());
							e.printStackTrace();
							return null;
						}
					}
				'''
			]

		// TODO Síncrono
		/* 
		 * members+=eventDefinitionClass.toField("ketalMessageHandler", typeRef(BrokerMessageHandler))[
		 * 	static = true
		 * 	initializer = '''new «typeRef(KetalMessageHandler)»()'''
		 * ]
		 * members+=eventDefinitionClass.toField("eventBrokerHandler", typeRef(EventBroker))[
		 * 	static = true
		 * 	initializer = '''new «typeRef(JGroupsEventBroker)»("Eketal", ketalMessageHandler)'''
		 * ]
		 * members+=eventDefinitionClass
		 * .toMethod("multicastSync", typeRef(void))[
		 * 	parameters+=eventDefinitionClass.toParameter("evento", Event.typeRef)
		 * 	parameters+=eventDefinitionClass.toParameter("map", Map.typeRef)
		 * 	static = false
		 * 	body='''
		 * 		eventBrokerHandler.multicastSync(evento, map);
		 * 	'''
		 * ]
		 * members+=eventDefinitionClass.toMethod("getEvents", typeRef(Vector))[
		 * 	parameters+=eventDefinitionClass.toParameter("evento", Event.typeRef)
		 * 	static = true
		 * 	body='''
		 * 		return ((((«typeRef(KetalMessageHandler)») ketalMessageHandler).getVectorEvents()));
		 * 	'''
		 * ]		
		 */
		]
	}
	
	def StringConcatenationClient generateTcpProperties(String bindInterface, Protocol protocol, TreeSet<String> ips){
		val processedIps = processIps(ips);
		return '''
			«IF protocol==Protocol.TCP»
				"TCP(bind_port=7800;"+
			«ELSEIF protocol==Protocol.TCP_NIO2»
				"TCP_NIO2(bind_port=7800;"+
			«ENDIF»
			
			«IF bindInterface!==null»
				"bind_addr=match-interface:«bindInterface»;"+
			«ENDIF»
			
			"recv_buf_size=${tcp.recv_buf_size:130k};"+
			"send_buf_size=${tcp.send_buf_size:130k};"+
			"max_bundle_size=64K;"+
			"sock_conn_timeout=300):"+
			
			"TCPPING(async_discovery=true;"+
			"initial_hosts=${jgroups.tcpping.initial_hosts:«processedIps.join(",", [
				ip| ip+"[7800]"
			])»};"+
			
			«IF protocol==Protocol.TCP»
				"port_range=2):"+
			«ELSEIF protocol==Protocol.TCP_NIO2»
				"port_range=3):"+
			«ENDIF»
			"MERGE3(min_interval=10000;max_interval=30000):" +
			"FD_SOCK():" +
			«IF protocol==Protocol.TCP»
				"FD(timeout=12000):" +
			«ELSEIF protocol==Protocol.TCP_NIO2»
				"FD_ALL(timeout=12000;max_tries=3):" +
			«ENDIF»
			
			"VERIFY_SUSPECT(timeout=2000):" +
			"BARRIER():" +
		  	"pbcast.NAKACK2(use_mcast_xmit=false;discard_delivered_msgs=true):" +
		    "UNICAST3():"+
			"pbcast.STABLE(stability_delay=2000;desired_avg_gossip=50000;max_bytes=4M):" +
		    "pbcast.GMS(join_timeout=10000;print_local_addr=true;view_bundling=true):"+
			"MFC(max_credits=4M;min_threshold=0.4):"+
			"FRAG2(frag_size=60k):" +
			"pbcast.STATE_TRANSFER()"
			'''
	}
	
	def processIps(TreeSet<String> set) {
		val TreeSet<String> retorno = new TreeSet
		set.forEach[ip | 
			if(ip.contains("[")){
				var splitIp = ip.split(Pattern.quote("["))
				var limits = splitIp.get(1).substring(0,splitIp.get(1).length-1).split(Pattern.quote("-"))
				for(var i = Integer.parseInt(limits.get(0)); i<=Integer.parseInt(limits.get(1)); i++){
					retorno.add(splitIp.get(0)+i)
				}
			}else if(ip.contains("*")){
				
			}else{
				retorno.add(ip)				
			}
		]
		return retorno
	}
	
	def StringConcatenationClient generateUDP(String bindInterface) {
		return '''
			"UDP(mcast_port=${jgroups.udp.mcast_port:45588};"+
				"bind_addr=match-interface:«bindInterface»;"+
				
				"tos=8;"+
				"ucast_recv_buf_size=210K;"+
				"ucast_send_buf_size=210K;"+
			    "mcast_recv_buf_size=210K;"+
			    "mcast_send_buf_size=210K;"+
			    "max_bundle_size=64K;"+
			    "max_bundle_timeout=30;"+
			    "enable_diagnostics=true;"+
			    "thread_naming_pattern=cl;"+
			    "logical_addr_cache_max_size=1000;"+
				
			    "timer_type=new3;"+
			    "timer.min_threads=2;"+
			    "timer.max_threads=4;"+
			    "timer.keep_alive_time=3000;"+
			    "timer.queue_max_size=500;"+
				"timer.rejection_policy=abort;"+
		
			    "thread_pool.enabled=true;"+
			    "thread_pool.min_threads=10;"+
			    "thread_pool.max_threads=80;"+
			    "thread_pool.keep_alive_time=5000;"+
			    "thread_pool.queue_enabled=true;"+
			    "thread_pool.queue_max_size=50000;"+
			    "thread_pool.rejection_policy=discard;"+
		
			    "oob_thread_pool.enabled=true;"+
			    "oob_thread_pool.min_threads=5;"+
			    "oob_thread_pool.max_threads=80;"+
			    "oob_thread_pool.keep_alive_time=5000;"+
			    "oob_thread_pool.rejection_policy=discard):"+
		
				"PING(break_on_coord_rsp=true):" +
				"MERGE3(min_interval=10000;max_interval=30000):" +
		
				"FD_SOCK():" +
				"FD_ALL(timeout=12000):" +
				"VERIFY_SUSPECT(timeout=2000):" +
				"BARRIER():" +
		
			  	"pbcast.NAKACK2(use_mcast_xmit=true;xmit_interval=500;xmit_table_num_rows=100;xmit_table_msgs_per_row=2000;"+
				"xmit_table_max_compaction_time=35000;max_msg_batch_size=500;discard_delivered_msgs=true):" +
						   
			    "UNICAST3(xmit_interval=500;xmit_table_num_rows=100;xmit_table_msgs_per_row=2000;"+
			    "xmit_table_max_compaction_time=60000;max_msg_batch_size=500):"+
		
				"pbcast.STABLE(stability_delay=2000;desired_avg_gossip=50000;max_bytes=4M):" +
			    "pbcast.GMS(join_timeout=10000;print_local_addr=true;view_bundling=true,merge_timeout=7000,max_bundling_time=1000,resume_task_timeout=15000):"+
		
				"UFC(max_credits=4M;min_threshold=0.4):"+
				"MFC(max_credits=4M;min_threshold=0.4):"+
		
				"FRAG2(frag_size=60k):" +
			    "RSVP(resend_interval=2000;timeout=10000):"+
				//"pbcast.GMS(join_timeout=5000;print_local_addr=true;view_bundling=true):Causal(causal_order_prot_interest=false)";
				"pbcast.STATE_TRANSFER()"
		'''
	}

	def createGroupClass(IJvmDeclaredTypeAcceptor acceptor, EventClass claseGrupos) {
		acceptor.accept(claseGrupos.toClass("co.edu.icesi.eketal.groupsimpl." + PREFIX_NAME_FOR_GROUP_CLASSES)) [
//			annotations+=annotationRef(Singleton)
			val grupos = new TreeSet()
			claseGrupos.declarations.filter(typeof(Group)).forEach [
				val hosts = new TreeSet()
				it.hosts.forEach[host | hosts.add(host.ip)]
				grupos += "\"" + it.name + ":[" + processIps(hosts).join(",") + "]\""
			]

			members += claseGrupos.toField("SET_VALUES", typeRef("java.lang.String[]")) [
				static = true
				initializer = '''{«grupos.join(",")»}'''
			]

			members += claseGrupos.toField("grupos", typeRef(Map, typeRef(String), typeRef(Set, typeRef(URL)))) [
				static = true
				initializer = '''initializeGroups()'''
			]

			members += claseGrupos.toMethod("initializeGroups", typeRef(Map)) [
				static = true
				body = '''
					«Map» retorno = «Collections».synchronizedMap(new «Hashtable»());
					for(«typeRef(String)» s : SET_VALUES){
						«typeRef(String)»[] keyValue = s.replace("]","").split(«typeRef(Pattern)».quote(":["));
						«typeRef(Set, typeRef(URL))» values = new «typeRef(HashSet)»();
						for(«typeRef(String)» ip : keyValue[1].split(",")){
							try{
								if(ip.equals("localhost")){
									co.edu.icesi.eketal.handlercontrol.«PREFIX_NAME_FOR_EVENT_CLASSES» local = co.edu.icesi.eketal.handlercontrol.«PREFIX_NAME_FOR_EVENT_CLASSES».getInstance();
									values.add(new «typeRef(URL)»("http://"+local.getAsyncAddress().getHost()));
								}else{
									values.add(new «typeRef(URL)»("http://"+ip));
								}
							}catch(«typeRef(Exception)» e){
								e.printStackTrace();
							}
						}
						retorno.put(keyValue[0],values);
					}
					
					return retorno;
				'''
			]

			members += claseGrupos.toConstructor[]

			members += claseGrupos.toMethod("addGroup", typeRef(void)) [
				parameters += claseGrupos.toParameter("newGrupo", String.typeRef)
				parameters += claseGrupos.toParameter("hosts", typeRef(Set, typeRef(URL)))
				static = true
				body = '''
					grupos.put(newGrupo, hosts);
				'''
			]

			members += claseGrupos.toMethod("removeGroup", typeRef(Boolean)) [
				parameters += claseGrupos.toParameter("grupoEliminar", String.typeRef)
				static = true
				body = '''
					return grupos.remove(grupoEliminar)!=null;
				'''
			]

			// TODO realizar el llamado para ver
			members += claseGrupos.toMethod("on", typeRef(boolean)) [
				parameters += claseGrupos.toParameter("grupo", typeRef(String))
				static = true
				body = '''
					return true;
				'''
			]

			members += claseGrupos.toMethod("host", typeRef(boolean)) [
				parameters += claseGrupos.toParameter("nombreGrupo", typeRef(String))
				static = true
				body = '''
					if(grupos==null){
						return false;
					}
					co.edu.icesi.eketal.handlercontrol.«PREFIX_NAME_FOR_EVENT_CLASSES» local = co.edu.icesi.eketal.handlercontrol.«PREFIX_NAME_FOR_EVENT_CLASSES».getInstance();
					«typeRef(URL)» url = local.getAsyncAddress();
					«typeRef(boolean)» retorno = false;
					try{						
						retorno = grupos.get(nombreGrupo).contains(new «typeRef(URL)»("http://"+url.getHost()));
					}catch(«typeRef(Exception)» e){
						e.printStackTrace();
						retorno = false;
					}
					return retorno;
				'''
			]
		]
	}

	def initializeAutomaton(co.edu.icesi.eketal.eketal.Automaton declaracion) {
		val method = declaracion.toMethod("initialize", typeRef(State)) [
			parameters += declaracion.toParameter("transitionSet", typeRef(Set, typeRef(Transition)))
			parameters += declaracion.toParameter("estadosFinales", typeRef(Set, typeRef(State)))
			parameters += declaracion.toParameter("expressions",
				typeRef(Hashtable, typeRef(Expression), typeRef(Character)))
			static = true
			visibility = JvmVisibility::PRIVATE
			body = '''
				//Relación evento caracter
				«typeRef(Map, typeRef(String), typeRef(Character))» mapping = new «typeRef(TreeMap, typeRef(String), typeRef(Character))»();
				//Estado inicial
				«typeRef(State)» inicial = null;
				
				int consecutivo = 65;
				«Character» caracter = (char)consecutivo;
				«String» nombreEvento = "";
				«String» estadoLlegada = "";
				
				«FOR step : declaracion.steps»
					//Definición del estado: «step.name»
					String estado«step.name.toFirstUpper» = "«step.name»";
					estados.put(estado«step.name.toFirstUpper», new «typeRef(State)»());
					«IF step.type!==null && step.type==StateType.START»
						//«step.type» «StateType.START» «StateType.START_VALUE»
						//Estado inicial: «step.name»
						inicial = estados.get(estado«step.name.toFirstUpper»);
					«ENDIF»
				«ENDFOR»
				«FOR step : declaracion.steps»	
					«IF !step.transitions.isEmpty»
						«FOR transition : step.transitions»
							//Transicion de «transition.event.name» -> «transition.target.name»
							estadoLlegada = "«transition.target.name»";
							if(!estados.containsKey(estadoLlegada)){
								estados.put(estado«step.name.toFirstUpper», new «typeRef(State)»());
							}
							caracter = (char)consecutivo;
							consecutivo++;
							nombreEvento = "«transition.event.name»";
							if(!mapping.containsKey(nombreEvento)){
								mapping.put(nombreEvento, caracter);
								expressions.put(new «typeRef(DefaultEqualsExpression)»(new «typeRef(NamedEvent)»(nombreEvento)), mapping.get(nombreEvento));
							}
							«typeRef(Transition)» «step.name»«transition.event.name.toFirstUpper» = new «typeRef(Transition)»(estados.get(estado«step.name.toFirstUpper»), estados.get(estadoLlegada), mapping.get(nombreEvento));
							transitionSet.add(«step.name»«transition.event.name.toFirstUpper»);
							
						«ENDFOR»
					«ENDIF»
					«IF step.type==StateType.END»
						//Estado final «step.name.toFirstUpper»
						estados.get(estado«step.name.toFirstUpper»).setAccept(true);
						estadosFinales.add(estados.get(estado«step.name.toFirstUpper»));
						
					«ENDIF»
				«ENDFOR»
				return inicial;
			'''
		]
		return method
	}
//				members += automaton.toMethod("transiciones", typeRef(Set))[
//					abstract = true
//					static = true
//					visibility = JvmVisibility.PRIVATE
//					body = '''
//					return null;
//	   				'''
//				]
}
